import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:my_app/foodreccom/models/recipe/recipe.dart';
import 'package:my_app/foodreccom/providers/enhanced_recommendation_provider.dart';
import 'package:my_app/foodreccom/widgets/recipe_card.dart';
import 'package:my_app/foodreccom/widgets/recipe_detail/enhanced_recipe_detail_sheet.dart';
import 'package:my_app/foodreccom/extensions/ui_extensions.dart';
import 'package:my_app/foodreccom/widgets/status_card.dart';
import 'package:my_app/foodreccom/widgets/add_user_recipe_sheet.dart';
import 'package:my_app/foodreccom/meal_plan_page.dart';
import 'package:my_app/foodreccom/pages/cooking_history_page.dart';

class RecommendationPage extends StatefulWidget {
  const RecommendationPage({super.key});

  @override
  State<RecommendationPage> createState() => _RecommendationPageState();
}

class _RecommendationPageState extends State<RecommendationPage> {
  static const List<Map<String, dynamic>> _ingredientPresets = [
    {
      'label': '‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ñ‡∏£‡∏ö 3 ‡∏°‡∏∑‡πâ‡∏≠',
      'items': [
        '‡∏≠‡∏Å‡πÑ‡∏Å‡πà',
        '‡∏´‡∏°‡∏π‡∏™‡∏±‡∏ö',
        '‡πÑ‡∏Ç‡πà‡πÑ‡∏Å‡πà',
        '‡∏ú‡∏±‡∏Å‡∏Å‡∏≤‡∏î‡∏Ç‡∏≤‡∏ß',
        '‡πÅ‡∏Ñ‡∏£‡∏≠‡∏ó',
        '‡πÄ‡∏´‡πá‡∏î‡∏ü‡∏≤‡∏á',
        '‡∏Ñ‡∏∞‡∏ô‡πâ‡∏≤',
        '‡∏Ç‡πâ‡∏≤‡∏ß‡∏´‡∏≠‡∏°‡∏°‡∏∞‡∏•‡∏¥',
        '‡πÄ‡∏™‡πâ‡∏ô‡∏´‡∏°‡∏µ‡πà',
        '‡∏ô‡πâ‡∏≥‡∏õ‡∏•‡∏≤',
        '‡∏ã‡∏µ‡∏≠‡∏¥‡πä‡∏ß‡∏Ç‡∏≤‡∏ß',
        '‡∏Å‡∏£‡∏∞‡πÄ‡∏ó‡∏µ‡∏¢‡∏°',
      ],
    },
    {
      'label': '‡∏£‡∏±‡∏Å‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û/‡∏Ñ‡∏∏‡∏°‡πÅ‡∏Ñ‡∏•',
      'items': [
        '‡∏õ‡∏•‡∏≤‡πÅ‡∏ã‡∏•‡∏°‡∏≠‡∏ô',
        '‡∏≠‡∏Å‡πÑ‡∏Å‡πà‡∏á‡∏ß‡∏á',
        '‡πÄ‡∏ï‡πâ‡∏≤‡∏´‡∏π‡πâ‡πÅ‡∏Ç‡πá‡∏á',
        '‡πÑ‡∏Ç‡πà‡∏Ç‡∏≤‡∏ß',
        '‡∏ö‡∏£‡πá‡∏≠‡∏Ñ‡πÇ‡∏Ñ‡∏•‡∏µ',
        '‡∏°‡∏∞‡πÄ‡∏Ç‡∏∑‡∏≠‡πÄ‡∏ó‡∏®‡πÄ‡∏ä‡∏≠‡∏£‡πå‡∏£‡∏µ',
        '‡∏ú‡∏±‡∏Å‡πÇ‡∏Ç‡∏°',
        '‡∏ü‡∏±‡∏Å‡∏ó‡∏≠‡∏á',
        '‡∏Ñ‡∏ß‡∏¥‡∏ô‡∏±‡∏ß',
        '‡∏Ç‡πâ‡∏≤‡∏ß‡∏Å‡∏•‡πâ‡∏≠‡∏á',
        '‡∏°‡∏±‡∏ô‡∏´‡∏ß‡∏≤‡∏ô',
        '‡πÇ‡∏¢‡πÄ‡∏Å‡∏¥‡∏£‡πå‡∏ï‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥',
        '‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô‡∏°‡∏∞‡∏Å‡∏≠‡∏Å',
      ],
    },
    {
      'label': '‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÑ‡∏ó‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏≥',
      'items': [
        '‡∏™‡∏∞‡πÇ‡∏û‡∏Å‡πÑ‡∏Å‡πà',
        '‡∏Å‡∏∏‡πâ‡∏á',
        '‡∏õ‡∏•‡∏≤‡∏î‡∏≠‡∏•‡∏•‡∏µ‡πà',
        '‡∏´‡∏°‡∏π‡∏™‡∏≤‡∏°‡∏ä‡∏±‡πâ‡∏ô',
        '‡∏ñ‡∏±‡πà‡∏ß‡∏ù‡∏±‡∏Å‡∏¢‡∏≤‡∏ß',
        '‡∏û‡∏£‡∏¥‡∏Å‡∏ä‡∏µ‡πâ‡∏ü‡πâ‡∏≤',
        '‡πÉ‡∏ö‡∏°‡∏∞‡∏Å‡∏£‡∏π‡∏î',
        '‡∏°‡∏∞‡πÄ‡∏Ç‡∏∑‡∏≠‡∏û‡∏ß‡∏á',
        '‡πÇ‡∏´‡∏£‡∏∞‡∏û‡∏≤',
        '‡∏Ç‡πâ‡∏≤‡∏ß‡πÄ‡∏™‡∏≤‡πÑ‡∏´‡πâ',
        '‡πÄ‡∏™‡πâ‡∏ô‡πÉ‡∏´‡∏ç‡πà',
        '‡∏ô‡πâ‡∏≥‡∏õ‡∏•‡∏≤',
        '‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡∏õ‡∏µ‡πä‡∏ö',
        '‡∏Å‡∏∞‡∏ó‡∏¥',
        '‡∏ô‡πâ‡∏≥‡∏û‡∏£‡∏¥‡∏Å‡πÅ‡∏Å‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏´‡∏ß‡∏≤‡∏ô',
      ],
    },
  ];

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<EnhancedRecommendationProvider>().getHybridRecommendations();
    });
  }

  int? _parseNumericInput(String value) {
    final trimmed = value.trim();
    if (trimmed.isEmpty) return null;
    final digits = trimmed.replaceAll(RegExp(r'[^0-9]'), '');
    if (digits.isEmpty) return null;
    return int.tryParse(digits);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.black),
          onPressed: () => Navigator.pop(context),
        ),
        title: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              height: 40,
              width: 40,
              child: IconButton(
                padding: EdgeInsets.zero,
                icon: const Icon(Icons.filter_list, color: Colors.black),
                onPressed: () => _showFilterSheet(context),
                tooltip: '‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£',
              ),
            ),
            const SizedBox(width: 8),
            'üç≥ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£'.asText(
              fontSize: 20,
              fontWeight: FontWeight.bold,
              color: Colors.black,
            ),
          ],
        ),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.history, color: Colors.black),
            onPressed: () async {
              final provider = context.read<EnhancedRecommendationProvider>();
              if (provider.cookingHistory.isEmpty) {
                await provider.loadCookingHistory();
              }
              if (!context.mounted) return;
              Navigator.of(context).push(
                MaterialPageRoute(builder: (_) => const CookingHistoryPage()),
              );
            },
            tooltip: '‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß',
          ),
          IconButton(
            icon: const Icon(Icons.bookmarks, color: Colors.black),
            tooltip: '‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏á',
            onPressed: _showUserRecipesMenu,
          ),
        ],
      ),
      body: Consumer<EnhancedRecommendationProvider>(
        builder: (context, provider, child) {
          return RefreshIndicator(
            onRefresh: provider.getHybridRecommendations,
            color: Colors.yellow[600],
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildRecommendations(provider),
                  const SizedBox(height: 80),
                ],
              ),
            ),
          );
        },
      ),
      floatingActionButton: Consumer<EnhancedRecommendationProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) return const SizedBox();
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              FloatingActionButton(
                heroTag: 'add_user_recipe',
                onPressed: () => showModalBottomSheet(
                  context: context,
                  isScrollControlled: true,
                  builder: (_) => const AddUserRecipeSheet(),
                ),
                backgroundColor: Colors.green[400],
                child: const Icon(Icons.add, color: Colors.white),
              ),
              const SizedBox(height: 12),
              FloatingActionButton(
                heroTag: 'weekly_meal_plan',
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute(builder: (_) => const MealPlanPage()),
                  );
                },
                backgroundColor: Colors.blue[600],
                child: const Icon(Icons.calendar_month, color: Colors.white),
                tooltip: '‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏°‡∏∑‡πâ‡∏≠‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå',
              ),
              const SizedBox(height: 12),
              FloatingActionButton(
                heroTag: 'refresh_recs',
                onPressed: () {
                  provider.getHybridRecommendations();
                  context.showSnack(
                    'ü§ñ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏≠‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡∏°‡πà ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢...',
                    color: Colors.yellow[700]!,
                  );
                },
                backgroundColor: Colors.yellow[600],
                child: const Icon(Icons.refresh, color: Colors.black),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showUserRecipesMenu() {
    final provider = context.read<EnhancedRecommendationProvider>();
    final recipes = provider.userRecommendations;
    if (recipes.isEmpty) {
      context.showSnack('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏á', color: Colors.orangeAccent);
      return;
    }

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (sheetCtx) {
        final maxHeight = MediaQuery.of(sheetCtx).size.height * 0.7;
        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    '‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏á'.asText(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.of(sheetCtx).pop(),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                ConstrainedBox(
                  constraints: BoxConstraints(maxHeight: maxHeight),
                  child: ListView.separated(
                    shrinkWrap: true,
                    itemCount: recipes.length,
                    separatorBuilder: (_, __) => const Divider(height: 1),
                    itemBuilder: (context, index) {
                      final recipe = recipes[index];
                      return ListTile(
                        leading: const Icon(
                          Icons.bookmark_added,
                          color: Colors.deepPurple,
                        ),
                        title: Text(recipe.name),
                        trailing: const Icon(Icons.chevron_right),
                        onTap: () {
                          Navigator.of(sheetCtx).pop();
                          Future.delayed(const Duration(milliseconds: 100), () {
                            if (!mounted) return;
                            _showRecipeDetail(recipe);
                          });
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildRecommendations(EnhancedRecommendationProvider provider) {
    if (provider.isLoading) {
      return const StatusCard.loading(
        title: 'ü§ñ AI + API ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π...',
        subtitle: '‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ üáπüá≠',
        color: Colors.yellow,
      );
    }

    final hasError = provider.error != null;
    final hybridRecipes = provider.hybridRecommendations;
    final hasUserRecipes = provider.userRecommendations.isNotEmpty;

    if (hasError && hybridRecipes.isEmpty) {
      return StatusCard.error(
        message: provider.error!,
        onRetry: () => provider.getHybridRecommendations(),
      );
    }

    if (hybridRecipes.isEmpty) {
      return StatusCard(
        icon: Icons.restaurant_menu,
        title: '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏°‡∏ô‡∏π‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö',
        subtitle: hasUserRecipes
            ? '‡∏Ñ‡∏∏‡∏ì‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏õ‡∏∏‡πà‡∏°‡∏°‡∏∏‡∏°‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô'
            : '‡∏•‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡∏°‡πà',
        color: Colors.green,
        action: hasUserRecipes
            ? ElevatedButton(
                onPressed: _showUserRecipesMenu,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.deepPurple,
                  foregroundColor: Colors.white,
                ),
                child: const Text('‡∏î‡∏π‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏á'),
              )
            : ElevatedButton(
                onPressed: () => provider.getHybridRecommendations(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.yellow[600],
                  foregroundColor: Colors.black,
                ),
                child: const Text('‡∏Ç‡∏≠‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡∏°‡πà'),
              ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            const Icon(
              Icons.restaurant_menu,
              color: Colors.green,
            ).withPadding(const EdgeInsets.all(8)),
            '‡πÄ‡∏°‡∏ô‡∏π‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ (Hybrid)'.asText(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ],
        ),
        const SizedBox(height: 16),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: hybridRecipes.length,
          itemBuilder: (context, index) {
            final recipe = hybridRecipes[index];
            return RecipeCard(
              recipe: recipe,
              showSourceBadge: true,
              compact: true,
              onTap: () => _showRecipeDetail(recipe),
            );
          },
        ),
      ],
    );
  }

  void _showRecipeDetail(RecipeModel recipe) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => EnhancedRecipeDetailSheet(recipe: recipe),
    );
  }

  Future<void> _showFilterSheet(BuildContext context) async {
    final provider = context.read<EnhancedRecommendationProvider>();
    if (provider.ingredients.isEmpty) {
      await provider.loadIngredients();
    }
    final cuisines = const [
      {'th': '‡πÑ‡∏ó‡∏¢', 'en': 'thai'},
      {'th': '‡∏à‡∏µ‡∏ô', 'en': 'chinese'},
      {'th': '‡∏ç‡∏µ‡πà‡∏õ‡∏∏‡πà‡∏ô', 'en': 'japanese'},
      {'th': '‡πÄ‡∏Å‡∏≤‡∏´‡∏•‡∏µ', 'en': 'korean'},
      {'th': '‡πÄ‡∏ß‡∏µ‡∏¢‡∏î‡∏ô‡∏≤‡∏°', 'en': 'vietnamese'},
      {'th': '‡∏≠‡∏¥‡∏ô‡πÄ‡∏î‡∏µ‡∏¢', 'en': 'indian'},
      {'th': '‡∏≠‡πÄ‡∏°‡∏£‡∏¥‡∏Å‡∏≤', 'en': 'american'},
      {'th': '‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©', 'en': 'british'},
      {'th': '‡∏ù‡∏£‡∏±‡πà‡∏á‡πÄ‡∏®‡∏™', 'en': 'french'},
      {'th': '‡πÄ‡∏¢‡∏≠‡∏£‡∏°‡∏±‡∏ô', 'en': 'german'},
      {'th': '‡∏≠‡∏¥‡∏ï‡∏≤‡πÄ‡∏•‡∏µ‡∏¢‡∏ô', 'en': 'italian'},
      {'th': '‡πÄ‡∏°‡πá‡∏Å‡∏ã‡∏¥‡∏Å‡∏±‡∏ô', 'en': 'mexican'},
      {'th': '‡∏™‡πÄ‡∏õ‡∏ô', 'en': 'spanish'},
    ];
    final dietKeys = const [
      'Vegan',
      'Vegetarian',
      'Lacto-Vegetarian',
      'Ovo-Vegetarian',
      'Ketogenic',
      'Paleo',
      'Gluten-Free',
      'Dairy-Free',
      'Low-Fat',
      'High-Protein',
      'Low-Carb',
    ];

    final current = provider.filters;
    final selectedCuisine = current.cuisineEn.toSet();
    final selectedDiet = current.dietGoals
        .map((e) => e[0].toUpperCase() + e.substring(1))
        .toSet();
    final minCalController = TextEditingController(
      text: current.minCalories?.toString() ?? '',
    );
    final maxCalController = TextEditingController(
      text: current.maxCalories?.toString() ?? '',
    );
    final minProteinController = TextEditingController(
      text: current.minProtein?.toString() ?? '',
    );
    final maxCarbsController = TextEditingController(
      text: current.maxCarbs?.toString() ?? '',
    );
    final maxFatController = TextEditingController(
      text: current.maxFat?.toString() ?? '',
    );
    final controllers = <TextEditingController>[
      minCalController,
      maxCalController,
      minProteinController,
      maxCarbsController,
      maxFatController,
    ];
    final manualNames = (current.manualIngredientNames ?? []).toSet();
    String? activePreset = _activePresetFor(manualNames);
    final shownWarningCombos = <String>{};
    final shownPraiseCombos = <String>{};

    final sheetFuture = showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (context, setState) {
            const conflictMap = <String, Set<String>>{
              'Vegan': {
                'Vegetarian',
                'Lacto-Vegetarian',
                'Ovo-Vegetarian',
                'Ketogenic',
                'Paleo',
                'High-Protein',
              },
              'Vegetarian': {'Vegan', 'Paleo', 'Dairy-Free'},
              'Lacto-Vegetarian': {'Vegan', 'Ovo-Vegetarian', 'Dairy-Free'},
              'Ovo-Vegetarian': {'Vegan', 'Lacto-Vegetarian'},
              'Ketogenic': {'Vegan', 'Low-Fat'},
              'Paleo': {'Vegan', 'Vegetarian', 'Low-Fat', 'Gluten-Free'},
              'High-Protein': {'Vegan'},
              'Low-Fat': {'Ketogenic', 'Paleo'},
              'Gluten-Free': {'Paleo'},
              'Dairy-Free': {'Lacto-Vegetarian', 'Vegetarian'},
            };
            const conflictReasons = <String, String>{
              'Vegan|Vegetarian':
                  '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Vegan ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á Vegetarian ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥',
              'Vegan|Lacto-Vegetarian':
                  'Vegan ‡∏´‡πâ‡∏≤‡∏°‡∏ó‡∏∏‡∏Å‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö Lacto ‡πÄ‡∏û‡∏¥‡πà‡∏°',
              'Vegan|Ovo-Vegetarian':
                  'Vegan ‡∏á‡∏î‡πÑ‡∏Ç‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Ovo-Vegetarian ‡∏à‡∏∞‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô',
              'Vegan|Ketogenic':
                  'Vegan ‡πÄ‡∏ô‡πâ‡∏ô‡∏û‡∏∑‡∏ä ‡∏™‡πà‡∏ß‡∏ô Ketogenic ‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏≤‡∏£‡πå‡∏ö‡∏ï‡πà‡∏≥‡πÅ‡∏•‡∏∞‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏™‡∏π‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏ã‡∏∂‡πà‡∏á‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ô',
              'Vegan|Paleo':
                  'Paleo ‡πÄ‡∏ô‡πâ‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÅ‡∏•‡∏∞‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö Vegan',
              'Vegan|High-Protein':
                  'High-Protein ‡πÉ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ‡πÄ‡∏ô‡πâ‡∏ô‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Vegan',
              'Vegetarian|Vegan':
                  '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Vegetarian ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏á‡∏î‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Vegan ‡πÅ‡∏ó‡∏ô',
              'Vegetarian|Paleo':
                  'Paleo ‡πÄ‡∏ô‡πâ‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Vegetarian',
              'Vegetarian|Dairy-Free':
                  'Vegetarian ‡∏°‡∏±‡∏Å‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏ô‡∏°‡∏ó‡∏î‡πÅ‡∏ó‡∏ô‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô ‡∏´‡∏≤‡∏Å‡∏á‡∏î‡∏ô‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ú‡∏ô Vegan ‡πÅ‡∏ó‡∏ô',
              'Lacto-Vegetarian|Vegan':
                  'Lacto-Vegetarian ‡∏¢‡∏±‡∏á‡∏ó‡∏≤‡∏ô‡∏ô‡∏°‡πÑ‡∏î‡πâ ‡∏™‡πà‡∏ß‡∏ô Vegan ‡∏á‡∏î‡∏ô‡∏° ‡∏à‡∏∂‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á',
              'Lacto-Vegetarian|Ovo-Vegetarian':
                  'Lacto- ‡πÅ‡∏•‡∏∞ Ovo-Vegetarian ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏≤‡∏á ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÉ‡∏î‡πÅ‡∏ö‡∏ö‡∏´‡∏ô‡∏∂‡πà‡∏á',
              'Lacto-Vegetarian|Dairy-Free':
                  '‡∏™‡∏π‡∏ï‡∏£ Lacto-Vegetarian ‡πÄ‡∏ô‡πâ‡∏ô‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏ô‡∏° ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Dairy-Free ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡∏à‡∏∂‡∏á‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ô',
              'Ovo-Vegetarian|Vegan':
                  'Ovo-Vegetarian ‡∏¢‡∏±‡∏á‡∏ó‡∏≤‡∏ô‡πÑ‡∏Ç‡πà‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà Vegan ‡∏á‡∏î‡πÑ‡∏Ç‡πà ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ',
              'Ovo-Vegetarian|Lacto-Vegetarian':
                  'Ovo ‡πÅ‡∏•‡∏∞ Lacto ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á',
              'Ketogenic|Vegan':
                  'Ketogenic ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏™‡∏π‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏ã‡∏∂‡πà‡∏á‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ö Vegan',
              'Ketogenic|Low-Fat':
                  'Ketogenic ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≤‡∏ô‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏™‡∏π‡∏á ‡πÅ‡∏ï‡πà Low-Fat ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥ ‡∏ã‡∏∂‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ô',
              'Paleo|Vegan':
                  'Paleo ‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÅ‡∏•‡∏∞‡πÑ‡∏Ç‡∏°‡∏±‡∏ô ‡∏à‡∏∂‡∏á‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ö Vegan',
              'Paleo|Vegetarian':
                  'Paleo ‡∏á‡∏î‡∏ò‡∏±‡∏ç‡∏û‡∏∑‡∏ä‡πÅ‡∏•‡∏∞‡∏û‡∏∑‡∏ä‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏ô‡∏¥‡∏î‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Vegetarian',
              'Paleo|Low-Fat':
                  'Paleo ‡πÉ‡∏ä‡πâ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏•‡∏±‡∏Å ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö Low-Fat',
              'Paleo|Gluten-Free':
                  'Paleo ‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏ò‡∏±‡∏ç‡∏û‡∏∑‡∏ä‡∏Å‡∏•‡∏π‡πÄ‡∏ï‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏Ñ‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≤‡∏° Paleo ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Gluten-Free ‡πÄ‡∏û‡∏¥‡πà‡∏°',
              'High-Protein|Vegan':
                  'High-Protein ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Vegan',
              'Low-Fat|Ketogenic':
                  'Low-Fat ‡πÅ‡∏•‡∏∞ Ketogenic ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏±‡∏ô',
              'Low-Fat|Paleo':
                  'Paleo ‡∏≠‡∏¥‡∏á‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏à‡∏≤‡∏Å‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡∏ô‡∏¥‡∏î ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö Low-Fat',
            };
            String comboKey(String a, String b) {
              final items = [a, b]..sort();
              return items.join('|');
            }

            final cautionCombos = <String, String>{
              comboKey(
                'Vegetarian',
                'Low-Carb',
              ): '‡πÄ‡∏°‡∏ô‡∏π‡∏°‡∏±‡∏á‡∏™‡∏ß‡∏¥‡∏£‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏£‡πå‡∏ö‡∏ï‡πà‡∏≥‡∏°‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏≤‡∏Å ‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏≤‡∏à‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡πÄ‡∏î‡∏¥‡∏°‡∏ö‡πà‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô',
              comboKey(
                'Vegan',
                'Low-Fat',
              ): '‡∏Å‡∏≤‡∏£‡∏Å‡∏¥‡∏ô‡πÅ‡∏ö‡∏ö Vegan ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏•‡∏î‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏≠‡∏≤‡∏à‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏î‡∏µ‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏ô‡πâ‡∏ô‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡∏°‡∏µ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏à‡∏≤‡∏Å‡∏û‡∏∑‡∏ä‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÉ‡∏´‡πâ',
              comboKey(
                'High-Protein',
                'Low-Fat',
              ): '‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÅ‡∏´‡∏•‡πà‡∏á‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏™‡∏π‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î',
              comboKey(
                'Vegan',
                'Gluten-Free',
              ): '‡∏Å‡∏≤‡∏£‡∏Å‡∏¥‡∏ô‡πÅ‡∏ö‡∏ö Vegan ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏≤‡∏®‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏π‡πÄ‡∏ï‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÅ‡∏Ñ‡∏ö‡∏°‡∏≤‡∏Å ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏Ñ‡∏£‡∏ö‡∏´‡∏°‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á',
              comboKey(
                'Vegetarian',
                'Gluten-Free',
              ): '‡∏°‡∏±‡∏á‡∏™‡∏ß‡∏¥‡∏£‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡∏π‡πÄ‡∏ï‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏ò‡∏±‡∏ç‡∏û‡∏∑‡∏ä‡∏ó‡∏î‡πÅ‡∏ó‡∏ô ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏Ñ‡∏±‡∏î‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏Ñ‡∏≤‡∏£‡πå‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏Å‡∏•‡∏π‡πÄ‡∏ï‡∏ô‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏Ñ‡∏£‡∏ö‡∏™‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£',
              comboKey(
                'Vegan',
                'Dairy-Free',
              ): 'Vegan ‡∏á‡∏î‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏™‡∏±‡∏ï‡∏ß‡πå‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Dairy-Free ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÅ‡∏Ñ‡∏•‡πÄ‡∏ã‡∏µ‡∏¢‡∏°‡πÅ‡∏•‡∏∞‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏à‡∏≤‡∏Å‡∏û‡∏∑‡∏ä‡πÉ‡∏´‡πâ‡∏û‡∏≠ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏ï‡∏≠‡∏ö‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ô‡∏µ‡πâ',
              comboKey(
                'Vegetarian',
                'Dairy-Free',
              ): '‡∏°‡∏±‡∏á‡∏™‡∏ß‡∏¥‡∏£‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏á‡∏î‡∏ô‡∏°‡∏≠‡∏≤‡∏à‡∏Ç‡∏≤‡∏î‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡πÅ‡∏•‡∏∞‡πÅ‡∏Ñ‡∏•‡πÄ‡∏ã‡∏µ‡∏¢‡∏° ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ñ‡∏±‡πà‡∏ß‡πÅ‡∏•‡∏∞‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÉ‡∏´‡πâ‡πÅ‡∏ó‡∏ô',
            };
            final praiseCombos = <String, String>{
              comboKey(
                'Low-Fat',
                'Low-Carb',
              ): '‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ó‡∏±‡πâ‡∏á‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≤‡∏£‡πå‡∏ö ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏π‡πÅ‡∏•‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏¢‡∏±‡πà‡∏á‡∏¢‡∏∑‡∏ô',
              comboKey(
                'Vegetarian',
                'Low-Fat',
              ): '‡∏°‡∏±‡∏á‡∏™‡∏ß‡∏¥‡∏£‡∏±‡∏ï‡∏¥‡πÅ‡∏ö‡∏ö‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏ï‡πà‡∏≥‡∏ä‡πà‡∏ß‡∏¢‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡πÇ‡∏£‡∏Ñ‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏•‡∏≠‡∏î‡πÄ‡∏•‡∏∑‡∏≠‡∏î',
              comboKey(
                'Ketogenic',
                'High-Protein',
              ): '‡∏Ñ‡∏µ‡πÇ‡∏ï‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏°‡∏ß‡∏•‡∏Å‡∏•‡πâ‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠ ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠',
              comboKey(
                'Gluten-Free',
                'Dairy-Free',
              ): '‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏•‡∏π‡πÄ‡∏ï‡∏ô‡πÅ‡∏•‡∏∞‡∏ô‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏ó‡∏µ‡πà‡πÅ‡∏û‡πâ‡∏™‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏¢‡∏±‡∏á‡∏Ñ‡∏±‡∏î‡πÄ‡∏°‡∏ô‡∏π‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•‡∏™‡∏≤‡∏£‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            };

            List<String> applyDietConflicts(String diet) {
              final conflicts = conflictMap[diet] ?? const {};
              final removed = <String>[];
              for (final c in conflicts) {
                if (selectedDiet.remove(c)) {
                  removed.add(c);
                }
              }
              return removed;
            }

            Future<void> showConflictDialog(
              String diet,
              List<String> removed,
            ) async {
              if (removed.isEmpty) return;
              final detail = removed
                  .map(
                    (item) =>
                        '‚Ä¢ $item: ${conflictReasons['$diet|$item'] ?? conflictReasons['$item|$diet'] ?? '‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô'}',
                  )
                  .join('\n');
              final message = '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö $diet ‡πÑ‡∏î‡πâ:\n$detail';
              return showDialog<void>(
                context: context,
                builder: (dialogCtx) => AlertDialog(
                  title: const Text('‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏±‡∏î‡∏Å‡∏±‡∏ô'),
                  content: Text(message),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(dialogCtx).pop(),
                      child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
                    ),
                  ],
                ),
              );
            }

            Future<void> evaluateComboAlerts() async {
              Future<void> runAlerts(
                Map<String, String> combos,
                Set<String> tracker,
                String title,
              ) async {
                for (final entry in combos.entries) {
                  final parts = entry.key.split('|');
                  final active =
                      selectedDiet.contains(parts[0]) &&
                      selectedDiet.contains(parts[1]);
                  if (active) {
                    if (!tracker.contains(entry.key)) {
                      tracker.add(entry.key);
                      await showDialog<void>(
                        context: context,
                        builder: (dialogCtx) => AlertDialog(
                          title: Text(title),
                          content: Text(entry.value),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.of(dialogCtx).pop(),
                              child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
                            ),
                          ],
                        ),
                      );
                    }
                  } else {
                    tracker.remove(entry.key);
                  }
                }
              }

              await runAlerts(cautionCombos, shownWarningCombos, '‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á');
              await runAlerts(praiseCombos, shownPraiseCombos, '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏°‡∏≤‡∏Å');
            }

            Future.microtask(() => evaluateComboAlerts());

            return DraggableScrollableSheet(
              expand: false,
              initialChildSize: 0.9,
              minChildSize: 0.6,
              builder: (context, scroll) {
                return SingleChildScrollView(
                  controller: scroll,
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const SizedBox(height: 8),
                      Center(
                        child: Container(
                          width: 40,
                          height: 4,
                          decoration: BoxDecoration(
                            color: Colors.grey[400],
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                      '‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏≠‡∏≤‡∏´‡∏≤‡∏£'.asText(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                      const SizedBox(height: 16),
                      '‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)'.asText(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                      if (_ingredientPresets.isNotEmpty) ...[
                        const SizedBox(height: 8),
                        Text(
                          '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏∏‡∏î‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤ (‡πÅ‡∏ï‡∏∞‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å)',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[700],
                          ),
                        ),
                        const SizedBox(height: 8),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: _ingredientPresets.map((preset) {
                            final label = preset['label'] as String;
                            final items = List<String>.from(
                              preset['items'] as List,
                            );
                            final selected = activePreset == label;
                            return ChoiceChip(
                              label: Text(label),
                              selected: selected,
                              onSelected: (_) {
                                setState(() {
                                  if (selected) {
                                    manualNames.clear();
                                    activePreset = null;
                                  } else {
                                    manualNames
                                      ..clear()
                                      ..addAll(items);
                                    activePreset = label;
                                  }
                                });
                              },
                            );
                          }).toList(),
                        ),
                      ],
                      const SizedBox(height: 8),
                      Consumer<EnhancedRecommendationProvider>(
                        builder: (_, provider, __) {
                          final ingredientNames =
                              provider.availableIngredientNames;
                          if (ingredientNames.isEmpty) {
                            return Padding(
                              padding: const EdgeInsets.symmetric(vertical: 8),
                              child: Text(
                                '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏î‡∏¥‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.grey[600],
                                ),
                              ),
                            );
                          }
                          return Wrap(
                            spacing: 8,
                            runSpacing: 8,
                            children: ingredientNames.map((name) {
                              final checked = manualNames.contains(name);
                              return FilterChip(
                                label: Text(name),
                                selected: checked,
                                onSelected: (v) {
                                  setState(() {
                                    if (v) {
                                      manualNames.add(name);
                                    } else {
                                      manualNames.remove(name);
                                    }
                                    activePreset = null;
                                  });
                                },
                              );
                            }).toList(),
                          );
                        },
                      ),
                      if (manualNames.isNotEmpty) ...[
                        const SizedBox(height: 12),
                        '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ß‡πâ'.asText(
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                        ),
                        const SizedBox(height: 8),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: (manualNames.toList()..sort())
                              .map(
                                (name) => InputChip(
                                  label: Text(name),
                                  onDeleted: () {
                                    setState(() {
                                      manualNames.remove(name);
                                      activePreset = null;
                                    });
                                  },
                                ),
                              )
                              .toList(),
                        ),
                      ],
                      const SizedBox(height: 16),
                      '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)'.asText(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                      ...cuisines.map((c) {
                        final en = c['en']!;
                        final th = c['th']!;
                        return CheckboxListTile(
                          contentPadding: EdgeInsets.zero,
                          value: selectedCuisine.contains(en),
                          title: Text(th),
                          onChanged: (v) {
                            setState(() {
                              if (v == true) {
                                selectedCuisine.add(en);
                              } else {
                                selectedCuisine.remove(en);
                              }
                            });
                          },
                        );
                      }),
                      const SizedBox(height: 8),
                      '‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)'.asText(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                      ...dietKeys.map((k) {
                        final key = k.toLowerCase();
                        return CheckboxListTile(
                          contentPadding: EdgeInsets.zero,
                          value: selectedDiet.contains(k),
                          title: Text(k),
                          onChanged: (v) async {
                            if (v == true) {
                              var removed = <String>[];
                              setState(() {
                                removed = applyDietConflicts(k);
                                selectedDiet.add(k);
                              });
                              await showConflictDialog(k, removed);
                              await evaluateComboAlerts();
                            } else {
                              setState(() {
                                selectedDiet.remove(k);
                              });
                              await evaluateComboAlerts();
                            }
                          },
                        );
                      }).toList(),
                      const SizedBox(height: 8),
                      '‡πÅ‡∏Ñ‡∏•‡∏≠‡∏£‡∏µ‡πà‡∏ï‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏π (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)'.asText(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                      ),
                      Row(
                        children: [
                          Expanded(
                            child: TextFormField(
                              keyboardType: TextInputType.number,
                              controller: minCalController,
                              decoration: const InputDecoration(
                                labelText: '‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (kcal)',
                              ),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: TextFormField(
                              keyboardType: TextInputType.number,
                              controller: maxCalController,
                              decoration: const InputDecoration(
                                labelText: '‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á (kcal)',
                              ),
                            ),
                          ),
                        ],
                      ),
                      // Macro thresholds: show only when the corresponding diet is selected
                      if (selectedDiet.contains('High-Protein') ||
                          selectedDiet.contains('Low-Carb') ||
                          selectedDiet.contains('Low-Fat'))
                        const SizedBox(height: 12),
                      if (selectedDiet.contains('High-Protein') ||
                          selectedDiet.contains('Low-Carb') ||
                          selectedDiet.contains('Low-Fat'))
                        '‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡∏ï‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü)'.asText(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                        ),
                      if (selectedDiet.contains('High-Protein'))
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: TextFormField(
                            keyboardType: TextInputType.number,
                            controller: minProteinController,
                            decoration: const InputDecoration(
                              labelText: 'High-Protein: ‡πÇ‡∏õ‡∏£‡∏ï‡∏µ‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥',
                              hintText: '‡πÄ‡∏ä‡πà‡∏ô 20',
                              suffixText: 'g',
                            ),
                          ),
                        ),
                      if (selectedDiet.contains('Low-Carb'))
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: TextFormField(
                            keyboardType: TextInputType.number,
                            controller: maxCarbsController,
                            decoration: const InputDecoration(
                              labelText: 'Low-Carb: ‡∏Ñ‡∏≤‡∏£‡πå‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î',
                              hintText: '‡πÄ‡∏ä‡πà‡∏ô 25',
                              suffixText: 'g',
                            ),
                          ),
                        ),
                      if (selectedDiet.contains('Low-Fat'))
                        Padding(
                          padding: const EdgeInsets.only(top: 8.0),
                          child: TextFormField(
                            keyboardType: TextInputType.number,
                            controller: maxFatController,
                            decoration: const InputDecoration(
                              labelText: 'Low-Fat: ‡πÑ‡∏Ç‡∏°‡∏±‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î',
                              hintText: '‡πÄ‡∏ä‡πà‡∏ô 15',
                              suffixText: 'g',
                            ),
                          ),
                        ),
                      const SizedBox(height: 16),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          TextButton(
                            onPressed: () {
                              Navigator.pop(context);
                            },
                            child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
                          ),
                          const SizedBox(width: 8),
                          ElevatedButton(
                            onPressed: () {
                              final appliedMinCal = _parseNumericInput(
                                minCalController.text,
                              );
                              final appliedMaxCal = _parseNumericInput(
                                maxCalController.text,
                              );
                              final appliedMinProtein = _parseNumericInput(
                                minProteinController.text,
                              );
                              final appliedMaxCarbs = _parseNumericInput(
                                maxCarbsController.text,
                              );
                              final appliedMaxFat = _parseNumericInput(
                                maxFatController.text,
                              );

                              provider.setCuisineFilters(
                                selectedCuisine.toList(),
                              );
                              provider.setDietGoals(
                                selectedDiet
                                    .map((e) => e.toLowerCase())
                                    .toSet(),
                              );
                              provider.setCalorieRange(
                                min: appliedMinCal,
                                max: appliedMaxCal,
                              );
                              // Apply thresholds only if the corresponding diet is selected
                              final sd = selectedDiet.toSet();
                              provider.setMacroThresholds(
                                minProtein: sd.contains('High-Protein')
                                    ? appliedMinProtein
                                    : null,
                                maxCarbs: sd.contains('Low-Carb')
                                    ? appliedMaxCarbs
                                    : null,
                                maxFat: sd.contains('Low-Fat')
                                    ? appliedMaxFat
                                    : null,
                              );
                              provider.setManualIngredientNames(
                                manualNames.isEmpty
                                    ? null
                                    : manualNames.toList(),
                              );
                              Navigator.pop(context);
                              provider.getHybridRecommendations();
                            },
                            child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            );
          },
        );
      },
    );
    sheetFuture.whenComplete(() {
      for (final controller in controllers) {
        controller.dispose();
      }
    });
  }

  String? _activePresetFor(Set<String> manualNames) {
    for (final preset in _ingredientPresets) {
      final items = List<String>.from(preset['items'] as List);
      if (manualNames.length == items.length &&
          items.every(manualNames.contains)) {
        return preset['label'] as String;
      }
    }
    return null;
  }
}
